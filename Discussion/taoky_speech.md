【More Stages, More Performance?】现在我们知道，奔腾 4 处理器的失败的原因之一是因为它的流水线太长了。但是为什么长流水线会对性能带来反作用？如果我们把原先的顺序执行当作只有一级的流水线的话，那么增加流水线的级数，带来更好的性能，这似乎没有问题。【切】但是无论如何，我们也见不到这样的场景。一亿级流水线，想想就很恐怖。首先，在我们的想象之中，长流水线带来的性能增益是有一定的理论支持的。【切】首先，用没有流水线时的时间比上加入了 $k$ 级流水线的时间，可以注意到，最终我们的流水线可以带来 $k$ 倍的加速。【切】其次，增加流水线级数减少了每一级的工作量，进而减少延迟，加快时钟速度，这一点之前付佳伟也提到了。【切】可只要我们想一想，如果我们真的有那种超长的流水线的话，事情会变成什么样子呢？【切】我们请出小明同学，这次，他一家子叫了一大帮人来做菜。想想看这个场景，还是挺搞笑的，至少可以肯定，他们没法在 50 分钟内做完菜了。现在两份优势重合在一起，本可以带来梦幻般的性能，但是，为什么会变成这样呢？【切】首先，流水线能够提高处理指令的吞吐率，但是没有办法提高执行单条指令的速度，相反，由于每一级之间加入了寄存器，处理单条指令的速度还会拖慢。【切】此外还有一个横在提高流水线效率的障碍——冒险【切】有三类冒险：数据冒险、结构冒险、控制冒险，当然这里不会对乱序执行之类的东西谈太多，不然就有点跑题了。【切】首先是数据冒险，当流水线中某条指令的数据依赖于在它之前，但还在流水线中的指令时，就可能会出现问题，毕竟，你不能在写入之前读取。【切】这里，指令 2 需要指令 1 写入的数据，但是那条数据还没有被写进去。【切】第二种是结构冒险，这里，是指在有的时候，一条指令需要的硬件资源还在被另一条指令占用，这通常是硬件设计上的问题，比如说，你给数据和指令的缓存只有一个的话，【切】这里，第一条指令需要~~擦车~~缓存来存结果，但是第六条指令需要缓存来读取指令，与数据冒险不同的是，第一条指令和第六条看起来是不冲突的，可能它们甚至都没有太大的关联。【切】最后是控制冒险，由于控制指令的存在，流水线要做到高效，就不可能一直无脑顺延把所有指令吞下去，跳转，特别是条件跳转，让流水线有执行错误的可能。当然，现代的处理器的分支预测，很大程度解决了这种问题。【切】这里，第一条指令要跳到 `0x23333333`，但是这条流水线直接把跳转指令之后的指令弄了进来，做了大量的无用功。由于这些障碍的存在，流水线不可以做得很长。那么，如何解决冒险？【切】其中一种方式是在流水线中加入「气泡」，这种方式称为流水线冒泡，或者叫流水线停顿。【切】拿数据冒险那张图，原先第二条指令会出现问题，但是加入气泡之后，第二条指令就能够顺利读取到需要的数据了。【切】好的，到此结束，谢谢大家。